pragma language_version >= 0.16.0;

module CryptoLibrary {
  import CompactStandardLibrary;

  /**
   * @dev Point to bytes conversion
   * @notice Converts a curve point to a 32-byte hash representation
   * @param p The curve point to convert
   * @return A 32-byte hash of the curve point
   */
  circuit curvePointToBytes(p: CurvePoint): Bytes<32> {
    return persistentHash<CurvePoint>(p);
  }

/**
 * @dev 96-byte structure
 * @notice Represents a 96-byte value split into three 32-byte segments
 * @param b0 First 32-byte segment
 * @param b1 Second 32-byte segment
 * @param b2 Third 32-byte segment
 */
struct Bytes96 {
  b0: Bytes<32>;
  b1: Bytes<32>;
  b2: Bytes<32>;
}

/**
 * @dev 64-byte structure
 * @notice Represents a 64-byte value split into two 32-byte segments
 * @param b0 First 32-byte segment
 * @param b1 Second 32-byte segment
 */
struct Bytes64 {
  b0: Bytes<32>;
  b1: Bytes<32>;
}

/**
 * @dev Digital signature structure
 * @notice Represents a cryptographic signature for credential verification
 * @param pk Public key curve point of the signer
 * @param R Random curve point used in signature generation
 * @param s Scalar field element completing the signature
 */
export struct Signature {
  pk: CurvePoint;
  R: CurvePoint;
  s: Field;
}

/**
 * @dev Credential subject structure
 * @notice Represents a credential subject as defined in the W3C Verifiable Credentials Data Model
 * @see <https://w3c-ccg.github.io/vc-data-model/#credential-subject>
 * @param id The subject's identifier (Midnight wallet public key)
 * @param firstName The subject's first name (hashed to 32 bytes)
 * @param lastName The subject's last name (hashed to 32 bytes)
 * @param nationalIdentifier The subject's national identifier (hashed to 32 bytes)
 * @param birthTimestamp The subject's birth timestamp in Unix time
 */
export struct CredentialSubject {
    id: Bytes<32>;
    firstName: Bytes<32>;
    lastName: Bytes<32>;
    nationalIdentifier: Bytes<32>;
    birthTimestamp: Uint<64>;
}

/**
 * @dev Signed credential subject structure
 * @notice Represents a credential subject with an issuer's digital signature for verification
 * @param subject The credential subject data (identity information)
 * @param signature The issuer's digital signature over the credential subject
 */
export struct SignedCredentialSubject {
  subject: CredentialSubject;
  signature: Signature;
}

/**
 * @dev Subject hash circuit
 * @notice Computes a persistent hash of a credential subject for canonical representation
 * @param credentialSubject The credential subject to hash
 * @return A 32-byte persistent hash of the credential subject
 */
export pure circuit subjectHash(credentialSubject: CredentialSubject): Bytes<32> {
  return persistentHash<CredentialSubject>(credentialSubject);
}

/**
 * @dev Derive public key circuit
 * @notice Derives a public key curve point from a private key using elliptic curve multiplication
 * @param skBytes The 32-byte private key
 * @return The corresponding public key as a curve point
 */
export pure circuit derivePk(skBytes: Bytes<32>): CurvePoint {
   const sk: Field = 0; //transientHash<Bytes<32>>(skBytes);
   const pk: CurvePoint = ecMulGenerator(sk);
   return pk;
}

/**
 * @dev Sign message circuit (original implementation)
 * @notice Creates a digital signature over a message using a private key and deterministic nonce
 * @param msg The 32-byte message to sign
 * @param skBytes The 32-byte private key
 * @return A Signature structure containing the public key, random point R, and scalar s
 */
/*
// Original way to sign
  export pure circuit sign(msg: Bytes<32>, skBytes: Bytes<32>): Signature {
  // Convert skBytes to Field
  const sk: Field = transientHash<Bytes<32>>(skBytes);
  // Compute public key: pk = sk * B
  const pk: CurvePoint = ecMulGenerator(sk);

  // Derive nonce k deterministically: k = H(skBytes || msg)
  const nonceInput: Bytes64 = Bytes64 { b0: skBytes, b1: msg };
  const k: Field = transientHash<Bytes64>(nonceInput); // Hash to scalar

  // Compute R = k * B
  const R: CurvePoint = ecMulGenerator(k);

  // Compute challenge: c = H(R || pk || msg)
  const rBytes: Bytes<32> = curvePointToBytes(R);
  const pkBytes: Bytes<32> = curvePointToBytes(pk);
  const cBytes: Bytes96 = Bytes96 {
    b0: rBytes,
    b1: pkBytes,
    b2: msg
  };
  const c: Field = transientHash<Bytes96>(cBytes);

  // Compute signature: s = k + c * sk
  const s: Field = k + (c * sk);

  return Signature { pk: pk, R: R, s: s };
}
*/

/**
 * @dev Sign message circuit (workaround implementation)
 * @notice Creates a digital signature using hardcoded field constants as a temporary workaround
 * @param msg The 32-byte message to sign
 * @param skBytes The 32-byte private key (currently unused due to workaround)
 * @return A Signature structure containing the public key, random point R, and scalar s
 * @custom:warning This is a temporary workaround using constant values. Not suitable for production use.
 * @custom:issue Awaiting resolution from Midnight team for proper field derivation from bytes
 */
// Workaround way to sign using a Field 2 (not resolved by Midnight team yet)
export pure circuit sign(msg: Bytes<32>, skBytes: Bytes<32>): Signature {
  // Use a small, valid constant for demonstration
  const sk: Field = 2; // Instead of deriving from skBytes
  const pk: CurvePoint = ecMulGenerator(sk);

  // Use another small, valid constant for the nonce
  const k: Field = 3; // Instead of deriving from hash
  const R: CurvePoint = ecMulGenerator(k);

  const rBytes: Bytes<32> = curvePointToBytes(R);
  const pkBytes: Bytes<32> = curvePointToBytes(pk);
  const cBytes: Bytes96 = Bytes96 {
    b0: rBytes,
    b1: pkBytes,
    b2: msg
  };
  const c: Field = transientHash<Bytes96>(cBytes);

  const s: Field = k + (c * sk);

  return Signature { pk: pk, R: R, s: s };
}

/**
 * @dev Verify signature circuit
 * @notice Verifies a digital signature by checking the Schnorr signature equation: s*G = R + c*pk
 * @param msg The 32-byte message that was signed
 * @param signature The signature structure containing pk, R, and s
 * @custom:throws Assertion error if signature verification fails
 */
// Original way to verify the signature
export pure circuit verifySignature(msg: Bytes<32>, signature: Signature): [] {
  const {pk, R, s} = signature;
  // Compute challenge: c = H(R || pk || msg)
  const rBytes: Bytes<32> = curvePointToBytes(R);
  const pkBytes: Bytes<32> = curvePointToBytes(pk);
  const cBytes: Bytes96 = Bytes96 {
    b0: rBytes,
    b1: pkBytes,
    b2: msg
  };
  const c: Field = transientHash<Bytes96>(cBytes);

  // Left-hand side: s * B
  const lhs: CurvePoint = ecMulGenerator(s);

  // Right-hand side: R + c * pk
  const cPk: CurvePoint = ecMul(pk, c);
  const rhs: CurvePoint = ecAdd(R, cPk);

  // Enforce verification equation
  assert(lhs == rhs, "Signature verification failed");
}

  /**
 * @dev Verify signature circuit (workaround implementation)
 * @notice Verifies a digital signature using a hardcoded scalar constant as a temporary workaround
 * @param msg The 32-byte message that was signed
 * @param signature The signature structure containing pk, R, and s (s component currently unused)
 * @custom:warning This is a temporary workaround using a constant value. Not suitable for production use.
 * @custom:issue Awaiting resolution from Midnight team for proper signature verification
 * @custom:throws Assertion error if signature verification fails
 */
/*
  // Workaround way to verify the signature (not resolved by Midnight team yet)
  export pure circuit verifySignature(msg: Bytes<32>, signature: Signature): [] {
    const {pk, R} = signature;
    // Use a constant Field value for demonstration
    const s: Field = 2;

    // Compute challenge: c = H(R || pk || msg)
    const rBytes: Bytes<32> = curvePointToBytes(R);
    const pkBytes: Bytes<32> = curvePointToBytes(pk);
    const cBytes: Bytes96 = Bytes96 {
      b0: rBytes,
      b1: pkBytes,
      b2: msg
    };
    const c: Field = transientHash<Bytes96>(cBytes);

    // Left-hand side: s * B
    const lhs: CurvePoint = ecMulGenerator(s);

    // Right-hand side: R + c * pk
    const cPk: CurvePoint = ecMul(pk, c);
    const rhs: CurvePoint = ecAdd(R, cPk);

    // Enforce verification equation
    assert(lhs == rhs, "Signature verification failed");
  }
  */
}
