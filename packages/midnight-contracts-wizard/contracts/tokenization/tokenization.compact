pragma language_version >= 0.16.0;

import CompactStandardLibrary;
import TokenizationLibrary;

/**
 * @dev Exported types
 * @notice Makes custom project types available to external consumers
 * - Project: Represents a crowdfunding project with its details and state
 * - ProjectStatus: Enum defining the possible states of a project
 */
export {Project, ProjectStatus};

/**
 * @dev Project status enumeration
 * @notice Defines the possible states a project can be in during its lifecycle
 * - Active: Project is currently accepting investments
 * - Withdrawn: Project has been withdrawn by the creator
 * - Closed: Project has reached its goal or deadline and is no longer accepting investments
 */
enum ProjectStatus {
    Active,
    Withdrawn,
    Closed
}

/**
 * @dev Protocol total value locked
 * @notice Maps coin types to their qualified coin information, tracking all coins deposited into the protocol
 */
export ledger protocolTVL: Map<Bytes<32>, QualifiedCoinInfo>;

/**
 * @dev Projects registry
 * @notice Maps project IDs to their project data, storing all projects created on-chain
 */
export ledger projects: Map<Bytes<32>, Project>;

/**
 * @dev Investor commitments
 * @notice Merkle tree storing investor commitment hashes anonymously using zero-knowledge proofs
 */
export ledger investors: MerkleTree<100, Bytes<32>>;


/**
 * @dev Project structure
 * @notice Represents a crowdfunding project with all its details and current state
 * @param id Unique identifier for the project
 * @param title Project title (opaque string)
 * @param desc Project description (opaque string)
 * @param owner Address of the project owner/creator
 * @param investmentGoal Target funding goal for the project
 * @param raised Total amount raised so far
 * @param investors Number of investors who have contributed
 * @param duration Project duration in time units
 * @param creationDate Timestamp when the project was created
 * @param status Current status of the project (Active, Withdrawn, or Closed)
 * @param coinType Type of coin accepted for investments
 */
struct Project {
    id: Bytes<32>;
    title: Opaque<"string">;
    desc: Opaque<"string">;
    owner: Bytes<32>;
    investmentGoal: Uint<128>;
    raised: Uint<128>;
    investors: Uint<128>;
    duration: Uint<128>;
    creationDate: Uint<128>;
    status: ProjectStatus;
    coinType: Bytes<32>;
}

/**
 * @dev Local secret key witness
 * @notice Provides the user's private secret key for generating commitments and identifiers
 * @return The user's 32-byte secret key
 */
witness localSecretKey(): Bytes<32>;

/**
 * @dev Project expiration check witness
 * @notice Verifies whether a project has expired based on its duration and start date
 * @param duration The project's duration in time units
 * @param startDate The timestamp when the project was created
 * @return Boolean indicating whether the project is still valid (false if expired)
 */
witness confirmProjectExpiration(duration: Uint<128>, startDate: Uint<128>): Boolean;

/**
 * @dev Investor commitment proof witness
 * @notice Finds the Merkle tree path for an investor's commitment hash to prove their investment anonymously
 * @param commitment The investor's commitment hash
 * @return The Merkle tree path proving the commitment exists in the investors tree
 */
witness findInvestor(commitment: Bytes<32>): MerkleTreePath<100, Bytes<32>>;


// =======================
//        Interaction for project creation and management
// =======================

/**
 * @dev Create project circuit
 * @notice Allows users to create a new crowdfunding project on-chain
 * @param projectId Unique identifier for the new project
 * @param investmentGoal Target funding goal for the project
 * @param duration Project duration in time units
 * @param coinType Type of coin accepted for investments
 * @param currentDate Current timestamp for recording the creation date
 * @param title Project title (opaque string)
 * @param desc Project description (opaque string)
 */
export circuit createProject(
    projectId: Bytes<32>,
    investmentGoal: Uint<128>,
    duration: Uint<128>,
    coinType: Bytes<32>,
    currentDate: Uint<128>,
    title: Opaque<"string">,
    desc: Opaque<"string">
): []  {
    const disclosedId = disclose(projectId); 
    assert (!projects.member(disclosedId), "Project with same ID already exists");
    
    // Generate a unique hash representing the project owner without revealing their public key
    const ownersHash = generateOwnersPK(ownPublicKey().bytes, disclose(localSecretKey()), disclosedId);
    
    const newProject = Project{   
        ...default<Project>,
        title: disclose(title),
        desc: disclose(desc),
        status: ProjectStatus.Active,
        investmentGoal: disclose(investmentGoal),
        duration: disclose(duration),
        owner: ownersHash,
        coinType: disclose(coinType),
        creationDate: disclose(currentDate)
    };
    
    projects.insert(disclosedId, newProject);
}

/**
 * @dev Cancel project circuit
 * @notice Allows the project owner to cancel and remove their project from the on-chain registry
 * @param projectId The unique identifier of the project to cancel
 */
export circuit cancelProject(projectId: Bytes<32>): []  {
    const disclosedId = disclose(projectId); 
    
    assert (projects.member(disclosedId), "Project with specified ID does not exist");
    const projectToEnd = projects.lookup(disclosedId);
    const reconstructedOwnersHash = generateOwnersPK(ownPublicKey().bytes, disclose(localSecretKey()), disclosedId);

    assert (reconstructedOwnersHash == projectToEnd.owner, "Can not end this project: You are not the owner");
    
    // Remove the project from the on-chain registry
    projects.remove(disclosedId);
}

/**
 * @dev Withdraw project funds circuit
 * @notice Allows the project owner to withdraw funds after the project reaches its goal or closes
 * @param projectId The unique identifier of the project to withdraw funds from
 */
export circuit withdrawProjectFunds(projectId: Bytes<32>): []{
    const disclosedId = disclose(projectId); 
    assert (projects.member(disclosedId), "Project with the specified ID does not exist");
    
    const projectToWithdrawFrom = projects.lookup(disclosedId);
    const reconstructedOwnersHash = generateOwnersPK(ownPublicKey().bytes, disclose(localSecretKey()), disclosedId);

    assert (reconstructedOwnersHash == projectToWithdrawFrom.owner, "Can not end this project: You are not the owner");
    assert (projectToWithdrawFrom.raised >= projectToWithdrawFrom.investmentGoal || projectToWithdrawFrom.status == ProjectStatus.Closed, "Project funds is less than the investment goal");

    const sendResult = send(
        protocolTVL.lookup(projectToWithdrawFrom.coinType), 
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        projectToWithdrawFrom.investmentGoal
    );

    sendResult.change.is_some ? 
    protocolTVL.insertCoin(projectToWithdrawFrom.coinType, sendResult.change.value, left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey())) :
    protocolTVL.remove(projectToWithdrawFrom.coinType);

    // Update the project status to Withdrawn
    projects.remove(disclosedId);

    const updateProject = Project{
        ...projectToWithdrawFrom,
        status: ProjectStatus.Withdrawn
    };

    projects.insert(disclosedId, updateProject);
}

/**
 * @dev End project circuit
 * @notice Allows the project owner to close their project at any time and return remaining funds
 * @param projectId The unique identifier of the project to close
 */
export circuit endProject(projectId: Bytes<32>): []  {
    const disclosedId = disclose(projectId); 
    
    assert (projects.member(disclosedId), "Project with specified ID does not exist");
    const projectToEnd = projects.lookup(disclosedId);
    const reconstructedOwnersHash = generateOwnersPK(ownPublicKey().bytes, disclose(localSecretKey()), disclosedId);

    assert (reconstructedOwnersHash == projectToEnd.owner, "Can not end this project: You are not the owner");
    
    if(projectToEnd.raised > 0){
        // Send raised funds to the project owner before closing
        const sendResult = send(
            protocolTVL.lookup(projectToEnd.coinType), 
            left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
            projectToEnd.raised
        );

        // Update protocol balance with any remaining change
        sendResult.change.is_some ? 
        protocolTVL.insertCoin(projectToEnd.coinType, sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) :
        protocolTVL.remove(projectToEnd.coinType);
    }

    // Update the project status to Closed
    projects.insert(disclosedId, Project{
        ...projectToEnd,
        status: ProjectStatus.Closed
    });
}

/**
 * @dev Update project circuit
 * @notice Allows the project owner to update their project's details while it's still active
 * @param projectId The unique identifier of the project to update
 * @param title New project title (opaque string)
 * @param desc New project description (opaque string)
 * @param investmentGoal New target funding goal for the project
 * @param duration New project duration in time units
 */
export circuit updateProject(
    projectId: Bytes<32>,
    title: Opaque<"string">,
    desc: Opaque<"string">,
    investmentGoal: Uint<128>,
    duration: Uint<128>
    ): []{
    const disclosedId = disclose(projectId); 
    assert (projects.member(disclosedId), "Project with the specified ID does not exist");
    const projectToUpdate = projects.lookup(disclosedId);
    assert (projectToUpdate.status != ProjectStatus.Withdrawn || projectToUpdate.status != ProjectStatus.Closed, "Can not edit project: This project has ended");
    
    const reconstructedOwnersHash = generateOwnersPK(ownPublicKey().bytes, disclose(localSecretKey()), disclosedId);
    assert (reconstructedOwnersHash == projectToUpdate.owner, "Can not end this project: You are not the owner");

    const updateProject = Project{   
        ...projectToUpdate,
        title: disclose(title),
        desc: disclose(desc),
        investmentGoal: disclose(investmentGoal),
        duration: disclose(duration),
    };
    
    projects.insert(disclosedId, updateProject);
}


/**
 * @dev Invest in project circuit
 * @notice Allows users to invest in an active project by depositing coins anonymously
 * @param coin The coin information containing the investment amount and type
 * @param projectId The unique identifier of the project to invest in
 */
export circuit investProject(coin: CoinInfo, projectId: Bytes<32>): []{
    const disclosedCoin = disclose(coin);
    const disclosedId = disclose(projectId);
    assert (projects.member(disclosedId), "Project with the specified ID does not exist");
    const projectToInvest = projects.lookup(disclosedId);
    assert (projectToInvest.raised < projectToInvest.investmentGoal, "Can not invest in this project: the investment objective of the project has been reached");
    const isProjectActive = confirmProjectExpiration(projectToInvest.duration, projectToInvest.creationDate);
    assert (isProjectActive, "Project with specified ID is no longer active");
    assert (projectToInvest.status != ProjectStatus.Withdrawn || projectToInvest.status != ProjectStatus.Closed, "Can not invest in the project: this project is finished");
    assert (coin.color == projectToInvest.coinType, "Insufficient funds provided");
    assert (coin.value <= projectToInvest.investmentGoal, "Amount is greater than investment goal");
    receive(disclosedCoin);

    const coinToInsert = protocolTVL.member(disclosedCoin.color) ? 
    mergeCoinImmediate(protocolTVL.lookup(disclosedCoin.color), disclosedCoin) :
    disclosedCoin;

    protocolTVL.insertCoin(
        disclosedCoin.color, 
        coinToInsert, 
        right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
    );

    const investor = Investor{
        id: disclose(localSecretKey()),
        investment: disclosedCoin.value as Uint<32>,
        coinType: disclosedCoin.color
    };

    // Create a zero-knowledge commitment of the investorâ€™s data (amount, currency, secret ID).
    // This commitment is stored in the investors Merkle Tree
    const investorCommit = generateCommit(investor, disclosedId);
    investors.insert(investorCommit);

    const updateProject = Project{
        ...projectToInvest,
        investors: (projectToInvest.investors + 1) as Uint<128>,
        raised: (projectToInvest.raised + disclosedCoin.value) as Uint<128>
    };

    projects.insert(disclosedId, updateProject);
}

/**
 * @dev Request refund circuit
 * @notice Allows an investor to request a refund from an active project using zero-knowledge proof of their investment
 * @param projectId The unique identifier of the project to request a refund from
 * @param refundAmount The amount the investor wishes to withdraw
 * @param amountDeposited The total amount the investor originally deposited
 */
export circuit requestRefund(projectId: Bytes<32>, refundAmount: Uint<32>, amountDeposited: Uint<32>): []{
    const disclosedId = disclose(projectId);

    assert (projects.member(disclosedId), "Project with the specified ID does not exist");
    const project = projects.lookup(disclosedId);
    assert (project.status != ProjectStatus.Withdrawn || project.status != ProjectStatus.Closed, "Can not refund: This project has ended");

    const investor = Investor{
        id: disclose(localSecretKey()),
        investment: disclose(amountDeposited),
        coinType: project.coinType
    };

    const investorsCommit = generateCommit(investor, disclosedId);

    const path = disclose(findInvestor(investorsCommit));

    // Verify that the commitment exists in the Merkle tree of investors
    assert(investors.checkRoot(merkleTreePathRoot<100, Bytes<32>>(path)), "You are not a valid investor for this project");
    assert (refundAmount <= amountDeposited, "Can not withdraw more than deposited amount");

    const sendResult = send(
        protocolTVL.lookup(project.coinType), 
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        disclose(refundAmount)
    );
sendResult.change.is_some ? 
    protocolTVL.insertCoin(project.coinType, sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) :
    protocolTVL.remove(project.coinType);

    const updateProject = Project {
        ...project,
        raised: (project.raised - disclose(refundAmount)) as Uint<128>
    };

    projects.insert(disclosedId, updateProject);
}