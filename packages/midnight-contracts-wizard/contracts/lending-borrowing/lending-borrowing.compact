pragma language_version >= 0.16.0;

import CompactStandardLibrary;

/**
 * @dev Total borrowed by asset
 * @notice Maps asset types (coin colors) to the total amount currently borrowed from the lending pool
 */
export ledger totalBorrowedByAsset: Map<Bytes<32>, Uint<128>>;

/**
 * @dev Total supplied by asset
 * @notice Maps asset types (coin colors) to the total amount currently supplied to the lending pool
 */
export ledger totalSuppliedByAsset: Map<Bytes<32>, Uint<128>>;

/**
 * @dev Supply positions registry
 * @notice Merkle tree storing anonymous supply position commitments for lenders
 * @custom:privacy Allows lenders to prove their supply positions without revealing identity
 */
export ledger supplyPositions: MerkleTree<100, Bytes<32>>;

/**
 * @dev Collateral positions registry
 * @notice Merkle tree storing anonymous collateral position commitments for borrowers
 * @custom:privacy Allows borrowers to prove their collateral positions without revealing identity
 */
export ledger collateralPositions: MerkleTree<100, Bytes<32>>;

/**
 * @dev Lending pool
 * @notice Maps asset types (coin colors) to their qualified coin information for lending operations
 * @custom:usage Stores available liquidity that can be borrowed by users
 */
export ledger lendingPool: Map<Bytes<32>, QualifiedCoinInfo>;

/**
 * @dev Collateral pool
 * @notice Maps position commitments to their qualified coin information for collateral management
 * @custom:usage Stores collateral deposited by borrowers to secure their loans
 */
export ledger collateralPool: Map<Bytes<32>, QualifiedCoinInfo>;

/**
 * @dev Interest rate model
 * @notice Maps asset types (coin colors) to their current interest rates in basis points
 * @custom:usage Used to determine borrowing costs and lending yields based on pool utilization
 */
export ledger interestRateModel: Map<Bytes<32>, Uint<64>>;

/**
 * @dev Current interest rate
 * @notice Stores the current global interest rate in basis points
 * @custom:usage Used to calculate interest accrual for supply and borrow positions
 */
export ledger interestRate: Uint<64>;

/**
 * @dev Collateral position structure
 * @notice Represents a user's collateral position with privacy-preserving commitments
 * @param userCommitment Anonymous user identifier (commitment hash)
 * @param collateralCommitment Commitment to the collateral amount (keeps amount private)
 * @param debtCommitment Commitment to the debt amount (keeps amount private)
 * @param assetType Type of collateral asset (coin color)
 * @param timestamp Unix timestamp when the position was created
 */
struct CollateralPosition {
    userCommitment: Bytes<32>;
    collateralCommitment: Bytes<32>;
    debtCommitment: Bytes<32>;
    assetType: Bytes<32>;
    timestamp: Uint<64>;
}

/**
 * @dev Supply position structure
 * @notice Represents a user's supply position with privacy-preserving commitments
 * @param userCommitment Anonymous user identifier (commitment hash)
 * @param supplyCommitment Commitment to the supply amount (keeps amount private)
 * @param assetType Type of asset supplied (coin color)
 * @param timestamp Unix timestamp when the position was created
 */
struct SupplyPosition {
    userCommitment: Bytes<32>;
    supplyCommitment: Bytes<32>;
    assetType: Bytes<32>;
    timestamp: Uint<64>;
}

/**
 * @dev Verify collateral ownership witness
 * @notice Proves that the user owns the collateral being deposited
 * @param amount The collateral amount to verify ownership for
 * @return Boolean indicating whether the user owns the specified collateral amount
 */
witness verifyCollateralOwnership(amount: Uint<128>): Boolean;

/**
 * @dev Verify health factor witness
 * @notice Proves that a position maintains the required collateral ratio privately
 * @param collateralProof The commitment to the collateral position
 * @param borrowAmount The amount being borrowed or already borrowed
 * @param price The oracle price for collateral valuation
 * @return Boolean indicating whether the health factor requirement is met
 */
witness verifyHealthFactor(collateralProof: Bytes<32>, borrowAmount: Uint<128>, price: Uint<128>): Boolean;

/**
 * @dev Verify liquidation eligibility witness
 * @notice Proves that a position is undercollateralized and eligible for liquidation
 * @param liquidationProof The proof that the position is undercollateralized
 * @return Boolean indicating whether the position can be liquidated
 */
witness verifyLiquidationEligibility(liquidationProof: Bytes<32>): Boolean;

/**
 * @dev Calculate liquidation bonus witness
 * @notice Computes the liquidation bonus (incentive) for liquidators
 * @param repaymentAmount The amount being repaid by the liquidator
 * @return The liquidation bonus amount to be awarded to the liquidator
 */
witness calculateLiquidationBonus(repaymentAmount: Uint<128>): Uint<128>;

/**
 * @dev Update or remove position witness
 * @notice Updates or removes a collateral position after liquidation
 * @param positionCommitment The commitment to the position being updated or removed
 * @return Empty tuple (no return value)
 */
witness updateOrRemovePosition(positionCommitment: Bytes<32>): [];

/**
 * @dev Update debt commitment witness
 * @notice Updates the debt commitment after a repayment or borrowing operation
 * @param positionCommitment The commitment to the position being updated
 * @param repaymentAmount The amount being repaid (reduces debt) or borrowed (increases debt)
 * @return The new debt commitment hash
 */
witness updateDebtCommitment(positionCommitment: Bytes<32>, repaymentAmount: Uint<128>): Bytes<32>;

/**
 * @dev Mark position repaid witness
 * @notice Marks a position as fully repaid, allowing collateral withdrawal
 * @param positionCommitment The commitment to the position being marked as repaid
 * @return Empty tuple (no return value)
 */
witness markPositionRepaid(positionCommitment: Bytes<32>): [];

/**
 * @dev Update collateral commitment witness
 * @notice Updates the collateral commitment after a withdrawal operation
 * @param positionCommitment The commitment to the position being updated
 * @param withdrawAmount The amount being withdrawn from collateral
 * @return The new collateral commitment hash
 */
witness updateCollateralCommitment(positionCommitment: Bytes<32>, withdrawAmount: Uint<128>): Bytes<32>;

/**
 * @dev Generate user commitment witness
 * @notice Creates an anonymous user identifier from a secret key
 * @param secretKey The user's secret key
 * @return A commitment hash representing the user anonymously
 */
witness generateUserCommitment(secretKey: Bytes<32>): Bytes<32>;

/**
 * @dev Calculate utilization rate witness
 * @notice Computes the pool utilization rate as (borrowed / supplied) * 10000
 * @param totalBorrowed Total amount currently borrowed from the pool
 * @param totalSupplied Total amount currently supplied to the pool
 * @return The utilization rate in basis points (0-10000)
 */
witness calculateUtilizationRate(totalBorrowed: Uint<128>, totalSupplied: Uint<128>): Uint<64>;

/**
 * @dev Apply interest rate model witness
 * @notice Calculates the interest rate based on the utilization rate using the protocol's rate model
 * @param utilizationRate The current pool utilization rate in basis points
 * @return The calculated interest rate in basis points
 */
witness applyInterestRateModel(utilizationRate: Uint<64>): Uint<64>;

/**
 * @dev Get secret key witness
 * @notice Provides the caller's secret key for commitment generation and ownership verification
 * @return The caller's 32-byte secret key
 */
witness getSecretKey(): Bytes<32>;

/**
 * @dev Get randomness witness
 * @notice Provides random bytes for commitment generation to ensure uniqueness
 * @return A 32-byte random value for cryptographic commitments
 */
witness getRandomness(): Bytes<32>;

/**
 * @dev Get current time witness
 * @notice Provides the current timestamp for recording position creation and updates
 * @return The current Unix timestamp in seconds
 */
witness getCurrentTime(): Uint<64>;

/**
 * @dev Verify position ownership witness
 * @notice Proves that the caller owns the specified position
 * @param positionCommitment The commitment to the position being verified
 * @return Boolean indicating whether the caller owns the position
 */
witness verifyPositionOwnership(positionCommitment: Bytes<32>): Boolean;

/**
 * @dev Verify health factor after withdrawal witness
 * @notice Proves that a position maintains the required collateral ratio after a withdrawal
 * @param positionCommitment The commitment to the position being verified
 * @param withdrawAmount The amount to be withdrawn from collateral
 * @return Boolean indicating whether the health factor remains sufficient after withdrawal
 */
witness verifyHealthFactorAfterWithdrawal(positionCommitment: Bytes<32>, withdrawAmount: Uint<128>): Boolean;

/**
 * @dev Find collateral position witness
 * @notice Provides the Merkle tree path for a collateral position's authorization proof
 * @param positionCommitment The commitment to the collateral position
 * @return The Merkle tree path proving the position exists in the collateral positions tree
 */
witness findCollateralPosition(positionCommitment: Bytes<32>): MerkleTreePath<100, Bytes<32>>;

/**
 * @dev Find supply position witness
 * @notice Provides the Merkle tree path for a supply position's authorization proof
 * @param userCommitment The user's commitment hash
 * @return The Merkle tree path proving the position exists in the supply positions tree
 */
witness findSupplyPosition(userCommitment: Bytes<32>): MerkleTreePath<100, Bytes<32>>;

/**
 * @dev Reduce debt commitment witness
 * @notice Updates the debt commitment after a repayment, reducing the debt amount
 * @param positionCommitment The commitment to the position being updated
 * @param repaymentAmount The amount being repaid to reduce the debt
 * @return The new debt commitment hash after reduction
 */
witness reduceDebtCommitment(positionCommitment: Bytes<32>, repaymentAmount: Uint<128>): Bytes<32>;

/**
 * @dev Get private oracle data witness
 * @notice Provides oracle data privately for zero-knowledge proof generation
 * @param dataKey The identifier for the oracle data feed
 * @return The oracle data value (kept private)
 */
witness getPrivateOracleData(dataKey: Bytes<32>): Uint<128>;

/**
 * @dev Get current debt witness
 * @notice Retrieves the current debt amount for a position
 * @param positionCommitment The commitment to the position
 * @return The current debt amount
 */
witness getCurrentDebt(positionCommitment: Bytes<32>): Uint<128>;

/**
 * @dev Deposit collateral circuit
 * @notice Allows users to deposit collateral anonymously with ZK proof of ownership
 * @param collateralCoin The coin to deposit as collateral
 * @param collateralAmount The amount being deposited (kept private)
 */
export circuit depositCollateral(
    collateralCoin: CoinInfo,
    collateralAmount: Uint<128>
): [] {
    // Verify coin ownership and amount privately
    assert(verifyCollateralOwnership(collateralAmount), "Invalid collateral");

    // Receive the collateral
    receive(disclose(collateralCoin));

    // Create anonymous position commitment
    const userCommit = generateUserCommitment(disclose(getSecretKey()));
    const collateralCommit = persistentCommit<Uint<128>>(disclose(collateralAmount), disclose(getRandomness()));

    // Store position anonymously in Merkle tree with explicit disclosure
    const position = CollateralPosition {
        userCommitment: userCommit,
        collateralCommitment: collateralCommit,
        debtCommitment: persistentCommit<Uint<128>>(0 as Uint<128>, disclose(getRandomness())),
        assetType: disclose(collateralCoin.color),
        timestamp: disclose(getCurrentTime())
    };

    collateralPositions.insert(disclose(userCommit));
}

/**
 * @dev Borrow circuit
 * @notice Allows users to borrow against collateral while proving health factor privately
 * @param borrowAmount The amount to borrow (kept private)
 * @param collateralProof ZK proof of sufficient collateral
 * @param priceKey Oracle price feed identifier
 */
export circuit borrow(
    borrowAmount: Uint<128>,
    collateralProof: Bytes<32>,
    priceKey: Bytes<32>
): [] {
    // Verify user has sufficient collateral using ZK proof
    const path = disclose(findCollateralPosition(collateralProof));
    assert(collateralPositions.checkRoot(merkleTreePathRoot<100, Bytes<32>>(path)), 
           "Invalid collateral position");
    
    // Get oracle price privately
    const price = getPrivateOracleData(disclose(priceKey));
    
    // Verify health factor privately
    assert(verifyHealthFactor(collateralProof, disclose(borrowAmount), price), 
           "Insufficient collateral ratio");
    
    // Update debt commitment
    const newDebtCommit = updateDebtCommitment(collateralProof, disclose(borrowAmount));
    
    // Send borrowed funds to user
    const sendResult = send(
        lendingPool.lookup(disclose(priceKey)),  // Now returns QualifiedCoinInfo
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        disclose(borrowAmount)
    );
    
    // Update lending pool balance with change
    sendResult.change.is_some ? 
    lendingPool.insertCoin(disclose(priceKey), sendResult.change.value, right<ZswapCoinPublicKey, ContractAddress>(kernel.self())) :
    lendingPool.remove(disclose(priceKey));
}

/**
 * @dev Liquidate position circuit
 * @notice Allows liquidators to liquidate undercollateralized positions with ZK proof
 * @param positionCommitment The commitment to the position being liquidated
 * @param liquidationProof ZK proof that position is undercollateralized
 * @param repaymentCoin Coin to repay the debt
 */
export circuit liquidatePosition(
    positionCommitment: Bytes<32>,
    liquidationProof: Bytes<32>,
    repaymentCoin: CoinInfo
): [] {
    // Verify position exists
    const path = disclose(findCollateralPosition(positionCommitment));
    assert(collateralPositions.checkRoot(merkleTreePathRoot<100, Bytes<32>>(path)), 
           "Position not found");
    
    // Verify position is undercollateralized using ZK proof
    assert(verifyLiquidationEligibility(liquidationProof), 
           "Position is not eligible for liquidation");
    
    // Receive repayment
    receive(disclose(repaymentCoin));
    
    // Calculate liquidation bonus (e.g., 5%)
    const liquidationBonus = calculateLiquidationBonus(disclose(repaymentCoin.value));
    
    // Transfer collateral to liquidator (with explicit disclosure)
    const collateralToTransfer = (disclose(repaymentCoin.value) + liquidationBonus) as Uint<128>;
    
    const sendResult = send(
        collateralPool.lookup(disclose(positionCommitment)),
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        disclose(collateralToTransfer)  // Add disclose() here
    );
    
    // Update or remove position
    updateOrRemovePosition(positionCommitment);
}

/**
 * @dev Repay debt circuit
 * @notice Allows users to repay their debt partially or fully
 * @param positionCommitment The commitment to the user's position
 * @param repaymentCoin The coin used for repayment
 * @param repaymentAmount The amount being repaid (kept private)
 */
export circuit repayDebt(
    positionCommitment: Bytes<32>,
    repaymentCoin: CoinInfo,
    repaymentAmount: Uint<128>
): [] {
    // Verify position ownership
    const path = disclose(findCollateralPosition(positionCommitment));
    assert(collateralPositions.checkRoot(merkleTreePathRoot<100, Bytes<32>>(path)), 
           "Position not found");
    
    // Verify user owns this position
    assert(verifyPositionOwnership(positionCommitment), "Not position owner");
    
    // Receive repayment
    receive(disclose(repaymentCoin));
    
    // Get current debt amount via witness
    const currentDebt = getCurrentDebt(positionCommitment);
    
    // Calculate new debt
    const newDebt = currentDebt - disclose(repaymentAmount);
    
    // Update debt commitment
    const newDebtCommit = persistentCommit<Uint<128>>(newDebt, disclose(getRandomness()));
    
    // If fully repaid, allow collateral withdrawal
    if (newDebt == 0 as Uint<128>) {
        // Mark position as repaid, allowing collateral withdrawal
        markPositionRepaid(positionCommitment);
    }
}

/**
 * @dev Withdraw collateral circuit
 * @notice Allows users to withdraw collateral while maintaining health factor
 * @param positionCommitment The commitment to the user's position
 * @param withdrawAmount The amount to withdraw (kept private)
 */
export circuit withdrawCollateral(
    positionCommitment: Bytes<32>,
    withdrawAmount: Uint<128>
): [] {
    // Verify position ownership
    assert(verifyPositionOwnership(positionCommitment), "Not position owner");
    
    // Verify withdrawal maintains health factor
    assert(verifyHealthFactorAfterWithdrawal(positionCommitment, disclose(withdrawAmount)), 
           "Withdrawal would violate health factor");
    
    // Send collateral to user
    const sendResult = send(
        collateralPool.lookup(disclose(positionCommitment)),
        left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()),
        disclose(withdrawAmount)
    );
    
    // Update collateral commitment
    updateCollateralCommitment(positionCommitment, disclose(withdrawAmount));
}

/**
 * @dev Supply to lending pool circuit
 * @notice Allows users to supply assets to earn interest
 * @param supplyCoin The coin to supply to the pool
 * @param supplyAmount The amount being supplied
 */
export circuit supplyToPool(
    supplyCoin: CoinInfo,
    supplyAmount: Uint<128>
): [] {
    // Receive supply
    receive(disclose(supplyCoin));
    
    // Create supply position commitment
    const userCommit = generateUserCommitment(disclose(getSecretKey()));
    const supplyCommit = persistentCommit<Uint<128>>(disclose(supplyAmount), disclose(getRandomness()));
    
    // Store supply position
    const supplyPosition = SupplyPosition {
        userCommitment: userCommit,
        supplyCommitment: supplyCommit,
        assetType: disclose(supplyCoin.color),
        timestamp: disclose(getCurrentTime())
    };
    
    supplyPositions.insert(disclose(userCommit));
    
    // Update total supplied (cast to Uint<128>)
    const currentTotal = totalSuppliedByAsset.lookup(disclose(supplyCoin.color));
    totalSuppliedByAsset.insert(disclose(supplyCoin.color), (currentTotal + disclose(supplyAmount)) as Uint<128>);
}

/**
 * @dev Calculate interest rate circuit
 * @notice Computes the current interest rate based on pool utilization
 * @param assetType The asset type (coin color) to calculate interest rate for
 * @return The current interest rate in basis points
 */
export circuit calculateInterestRate(assetType: Bytes<32>): Uint<64> {
    const totalBorrowed = totalBorrowedByAsset.lookup(disclose(assetType));
    const totalSupplied = totalSuppliedByAsset.lookup(disclose(assetType));

    // Calculate utilization rate using witness function
    const utilizationRate = calculateUtilizationRate(totalBorrowed, totalSupplied);

    // Apply interest rate model
    const interestRate = applyInterestRateModel(disclose(utilizationRate));

    return disclose(interestRate);
}